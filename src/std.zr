func dbg.panic[msg: String] : Void
    c.printf("PANIC: %s\n", msg)
    c.exit(1)

func io.print[x: String] : Void
    c.puts(x)

func io.print_i64[x: I64] : Void
    c.printf("%ld\n", x)

func str.nth[s: String, n: I64] : U8
    return _builtin_deref8(s + n)

func str.set[s: String, n: I64, c: U8] : Void
    _builtin_set8(s+n, c)

func str.is_whitespace[c: U8] : Bool
    return c == ' ' | c == 10 | c == 13 | c == 9

func str.concat[a: String, b: String] : String
    let c: String = c.malloc(c.strlen(a) + c.strlen(b) + 1)
    c.strcpy(c, a)
    c.strcat(c, b)
    return c

func str.find[s: String, c: U8] : I64
    let s_len: I64 = c.strlen(s)
    for i in 0..s_len
        if str.nth(s, i) == c
            return i
    return -1

func str.substr[s: String, start: I64, length: I64] : String
    if start < 0 | length < 0 | start + length > c.strlen(s)
        dbg.panic("String.substr out of bounds")

    let out: String = c.malloc(length + 1)
    c.strncpy(out, s + start, length)
    str.set(out, length, 0)
    return out

func str.trim[s: String] : String
    let start: I64 = 0
    let end: I64 = c.strlen(s) - 1

    while start <= end & str.is_whitespace(str.nth(s, start))
        start = start + 1

    while end >= start & str.is_whitespace(str.nth(s, end))
        end = end - 1

    return str.substr(s, start, end - start + 1)

func str.reverse[s: String] : String
    let len: I64 = c.strlen(s)
    let out: String = c.malloc(len + 1)

    for i in 0..len
        str.set(out, i, str.nth(s, len - i - 1))
    str.set(out, len, 0)
    return out

func io.read_line[]: String
    let buffer: String = c.malloc(1024)
    let sys_read: I64 = 0
    let stdin: I64 = 0
    c.syscall(sys_read, stdin, buffer, 1024)
    return buffer

func io.read_file[path: String]: String
    let file: Ptr = c.fopen(path, "rb")
    if !file
        dbg.panic("failed to open file")

    c.fseek(file, 0, 2)
    let size: I64 = c.ftell(file)
    c.rewind(file)

    let buffer: String = c.malloc(size + 1)

    let n: I64 = c.fread(buffer, 1, size, file)
    str.set(buffer, n, 0)
    c.fclose(file)
    return buffer

func io.write_file[path: String, content: String] : Void
    let file: Ptr = c.fopen(path, "wb")
    if !file
        dbg.panic("failed to open file")

    c.fwrite(content, 1, c.strlen(content), file)
    c.fclose(file)

func str.from_i64[n: I64] : String
    let x: String = c.malloc(21)
    c.sprintf(x, "%ld", n)
    return x

func str.parse_i64[s: String] : I64
    return c.strtol(s, 0, 0)

func math.gcd[a: I64, b: I64] : I64
    while b != 0
        let tmp: I64 = b
        b = a % b
        a = tmp
    return a

func math.min[a: I64, b: I64] : I64
    if a < b
        return a
    return b

func math.max[a: I64, b: I64] : I64
    if a > b
        return a
    return b

func math.abs[n: I64] : I64
    if n < 0
        return -n
    return n

func math.pow[b: I64, e: I64] : I64
    let out: I64 = 1
    for i in 0..e
        out = out * b
    return out

func math.lcm[a: I64, b: I64] : I64
    return (a * b) / math.gcd(a, b)

func math.isqrt[n: I64] : I64
    if n < 0
        return -1
    if n == 0 | n == 1
        return n

    let guess: I64 = n
    let next_guess: I64 = (guess + n / guess) / 2

    while next_guess < guess
        guess = next_guess
        next_guess = (guess + n / guess) / 2

    return guess

func math.is_prime[n: I64]: Bool
    if n <= 1
        return false
    if n == 2 | n == 3
        return true
    if n % 2 == 0 | n % 3 == 0
        return false

    let i: I64 = 5
    while i * i <= n
        if n % i == 0 | n % (i + 2) == 0
            return false
        i = i + 6
    return true

func math.urandom[]: I64
    let buffer: Ptr = c.malloc(8)
    let file: Ptr = c.fopen("/dev/urandom", "rb")
    c.fread(buffer, 8, 1, file)
    c.fclose(file)
    let n: I64 = _builtin_deref64(buffer)
    c.free(buffer)
    return n

func array.new[] : Array
    return c.calloc(1, 24)

func array.set[xs: Array, n: I64, x: I64] : Void
    let data: Ptr = _builtin_deref64(xs)
    _builtin_set64(data+n*8, x)

func array.push[xs: Array, x: I64] : Void
    let data: Ptr = _builtin_deref64(xs)
    let capacity: I64 = _builtin_deref64(xs+8)
    let size: I64 = _builtin_deref64(xs+16)

    if size == capacity
        let new_capacity: I64 = 4
        if capacity != 0
            new_capacity = capacity * 2
        let new_data: Ptr = c.realloc(data, new_capacity * 8)
        _builtin_set64(xs, new_data)
        _builtin_set64(xs+8, new_capacity)
        data = new_data

    _builtin_set64(data+size*8, x)
    _builtin_set64(xs+16, size + 1)

func array.size[xs: Array] : I64
    return _builtin_deref64(xs+16)

func array.free[xs: Array] : Void
    c.free(_builtin_deref64(xs))
    c.free(xs)

func os.time[] : I64
    let tv: Ptr = c.malloc(16)
    c.gettimeofday(tv, 0)
    let seconds: I64 = _builtin_deref64(tv)
    let microseconds: I64 = _builtin_deref64(tv+8)
    c.free(tv)
    return seconds * 1000 + microseconds / 1000

func os.listdir[path: String] : Array
    let dir: Ptr = c.opendir(path)
    let files: Array = []

    while true
        let entry: Ptr = c.readdir(dir)
        if entry == 0
            break

        let skip: Bool = false
        if str.nth(entry, 19) == '.'
            if str.nth(entry, 20) == 0
                skip = true
            else if str.nth(entry, 20) == '.'
                if str.nth(entry, 21) == 0
                    skip = true

        if !skip
            array.push(files, c.strdup(entry + 19))
    c.closedir(dir)
    return files

func bit.lshift[a: I64, b: I64] : I64
    return _builtin_lshift(a, b)

func bit.rshift[a: I64, b: I64] : I64
    return _builtin_rshift(a, b)

func crypto.hex_encode[s: String] : String
    let hex_chars: String = "0123456789abcdef"
    let s_len: I64 = c.strlen(s)
    let j: I64 = 0
    let out: String = c.malloc(s_len*2+1)

    for i in 0..s_len
        let high: U8 = bit.rshift(str.nth(s, i), 4) & 15
        let low: U8 = str.nth(s, i) & 15
        str.set(out, j, str.nth(hex_chars, high))
        str.set(out, j+1, str.nth(hex_chars, low))
        j = j + 2

    str.set(out, j, 0)
    return out

func crypto.from_hex_digit[d: U8] : I64
    if d >= 'a' & d <= 'f'
        return d - 'a' + 10
    if d >= 'A' & d <= 'F'
        return d - 'A' + 10
    return d - '0'

func crypto.hex_decode[s: String] : String
    let s_len: I64 = c.strlen(s)
    let i: I64 = 0
    let j: I64 = 0
    let out: String = c.malloc(s_len/2+1)

    while i < s_len
        str.set(out, j, crypto.from_hex_digit(str.nth(s, i)) * 16 + crypto.from_hex_digit(str.nth(s, i+1)))
        i = i + 2
        j = j + 1

    str.set(out, j, 0)
    return out

func crypto.rc4[key: String, plaintext: String]: String
    let S: String = c.malloc(256)
    for i in 0..256
        str.set(S, i, i)
    
    let j: I64 = 0
    let key_len: I64 = c.strlen(key)
    for i in 0..256
        j = (j + str.nth(S, i) + str.nth(key, i % key_len)) % 256
        let tmp: U8 = str.nth(S, i)
        str.set(S, i, str.nth(S, j))
        str.set(S, j, tmp)

    let i: I64 = 0
    j = 0
    let plaintext_len: I64 = c.strlen(plaintext)
    let ciphertext: String = c.malloc(plaintext_len+1)
    for n in 0..plaintext_len
        i = (i + 1) % 256
        j = (j + str.nth(S, i)) % 256

        let tmp: U8 = str.nth(S, i)
        str.set(S, i, str.nth(S, j))
        str.set(S, j, tmp)

        let r: I64 = str.nth(S, (str.nth(S, i) + str.nth(S, j)) % 256)
        str.set(ciphertext, n, r ^ str.nth(plaintext, n))

    str.set(ciphertext, plaintext_len, 0)
    c.free(S)
    return ciphertext

func crypto.base64_encode[s: String] : String
    let chars: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    let s_len: I64 = c.strlen(s)
    let out: String = c.malloc(s_len*2)
    let i: I64 = 0
    let j: I64 = 0

    while i < s_len
        let b1: U8 = str.nth(s, i)
        let b2: U8 = 0
        if i + 1 < s_len
            b2 = str.nth(s, i+1)
        let b3: U8 = 0
        if i + 2 < s_len
            b3 = str.nth(s, i+2)
        i = i + 3

        let triple: I64 = bit.lshift(b1, 16) | bit.lshift(b2, 8) | b3
        str.set(out, j,   str.nth(chars, bit.rshift(triple, 18) & 63))
        str.set(out, j+1, str.nth(chars, bit.rshift(triple, 12) & 63))
        str.set(out, j+2, str.nth(chars, bit.rshift(triple, 6) & 63))
        str.set(out, j+3, str.nth(chars, triple & 63))
        j = j + 4

    let padding: I64 = s_len % 3
    if padding == 1
        str.set(out, j-2, '=')
        str.set(out, j-1, '=')
    else if padding == 2
        str.set(out, j-1, '=')

    str.set(out, j, 0)
    return out

func crypto.base64_decode[s: String] : String
    let chars: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    let s_len: I64 = c.strlen(s)
    let out: String = c.malloc(s_len)
    let i: I64 = 0
    let j: I64 = 0

    while str.nth(s, s_len-1) == '='
        s_len = s_len - 1

    while i < s_len
        let s1: U8 = str.find(chars, str.nth(s, i))
        let s2: U8 = 0
        if i + 1 < s_len
            s2 = str.find(chars, str.nth(s, i+1))
        let s3: U8 = 0
        if i + 2 < s_len
            s3 = str.find(chars, str.nth(s, i+2))
        let s4: U8 = 0
        if i + 3 < s_len
            s4 = str.find(chars, str.nth(s, i+3))
        i = i + 4

        let triple: I64 = bit.lshift(s1, 18) | bit.lshift(s2, 12) | bit.lshift(s3, 6) | s4

        str.set(out, j, bit.rshift(triple, 16) & 255)
        j = j + 1
        if s3 != 64
            str.set(out, j, bit.rshift(triple, 8) & 255)
            j = j + 1
        if s4 != 64
            str.set(out, j, triple & 255)
            j = j + 1

    str.set(out, j, 0)
    return out

func net.listen[port: I64] : I64
    let s: I64 = c.socket(2, 1, 0)
    if s < 0
        return -1

    let sa: Ptr = c.calloc(1, 16)
    str.set(sa, 0, 2)
    str.set(sa, 1, 0)
    str.set(sa, 2, bit.rshift(port, 8) & 255)
    str.set(sa, 3, port & 255)

    if c.bind(s, sa, 16) < 0
        c.close(s)
        return -1
    c.free(sa)

    if c.listen(s, 1) < 0
        c.close(s)
        return -1
    
    return s

func net.connect[host: String, port: I64] : I64
    let he: Ptr = c.gethostbyname(host)
    if he == 0
        return -1

    let ip_ptr: Ptr = _builtin_deref64(_builtin_deref64(he + 24))

    let s: I64 = c.socket(2, 1, 0)
    if s < 0
        return -1

    let sa: Ptr = c.calloc(1, 16)
    str.set(sa, 0, 2)
    str.set(sa, 2, bit.rshift(port, 8) & 255)
    str.set(sa, 3, port & 255)
    str.set(sa, 4, _builtin_deref8(ip_ptr + 0))
    str.set(sa, 5, _builtin_deref8(ip_ptr + 1))
    str.set(sa, 6, _builtin_deref8(ip_ptr + 2))
    str.set(sa, 7, _builtin_deref8(ip_ptr + 3))

    if c.connect(s, sa, 16) < 0
        c.free(sa)
        c.close(s)
        return -1

    c.free(sa)
    return s